generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * -------------------- Auth / User --------------------
 */
model Account {
  id       String @id @default(cuid())
  name     String
  email    String @unique
  password String // must always be hashed in code
  role     Role   @default(USER)

  // Relations
  cart      Cart?
  orders    Order[]
  addresses Address[]
  payments  PaymentMethod[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum Role {
  USER
  ADMIN
}

/**
 * -------------------- User Details --------------------
 */
model PaymentMethod {
  id          String  @id @default(cuid())
  type        String // "credit_card", "paypal", etc
  last4       String // last 4 digits for UI only
  providerRef String? // token/id from Stripe/PayPal/etc
  account     Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Address {
  id         String  @id @default(cuid())
  street     String
  postalCode String
  city       String
  country    String
  account    Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId  String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * -------------------- Cart --------------------
 */
model Cart {
  id     String     @id @default(cuid())
  userId String     @unique
  user   Account    @relation(fields: [userId], references: [id], onDelete: Cascade)
  items  CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CartItem {
  id        String  @id @default(cuid())
  cartId    String
  productId String
  qty       Int     @default(1)
  unitPrice Decimal @db.Decimal(12, 2) // snapshot at add-to-cart

  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@unique([cartId, productId]) // prevent duplicate items
}

/**
 * -------------------- Catalog --------------------
 */
model Product {
  id             String   @id @default(cuid())
  sku            String   @unique
  slug           String   @unique
  name           String
  description    String   @db.Text
  price          Decimal  @db.Decimal(12, 2)
  compareAtPrice Decimal? @db.Decimal(12, 2)
  origin         String?  @db.VarChar(2) // ISO country code
  isActive       Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  categories Category[]
  cartItems  CartItem[]
  inventory  Inventory[]
  orderItems OrderItem[]
  discounts  DiscountOnProduct[]

  @@index([createdAt])
}

model Category {
  id       String    @id @default(cuid())
  name     String
  slug     String    @unique
  products Product[]

  @@unique([name])
}

/**
 * -------------------- Discounts --------------------
 */
model Discount {
  id         String    @id @default(cuid())
  name       String
  percentOff Decimal?  @db.Decimal(5, 2)
  amountOff  Decimal?  @db.Decimal(12, 2)
  validFrom  DateTime  @default(now())
  validUntil DateTime?

  products DiscountOnProduct[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Pivot table: many-to-many with metadata
model DiscountOnProduct {
  productId  String
  discountId String
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  discount   Discount @relation(fields: [discountId], references: [id], onDelete: Cascade)

  @@id([productId, discountId])
}

/**
 * -------------------- Warehouses & Inventory --------------------
 */
model Warehouse {
  id       String @id @default(cuid())
  code     String @unique
  name     String
  location String

  inventory  Inventory[]
  orderItems OrderItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Inventory {
  id          String @id @default(cuid())
  productId   String
  warehouseId String
  qty         Int    @default(0)

  product   Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Restrict)

  @@unique([productId, warehouseId])
  @@index([warehouseId])
  @@index([productId])
}

/**
 * -------------------- Orders --------------------
 */
model Order {
  id        String      @id @default(cuid())
  userId    String
  status    OrderStatus @default(PENDING)
  subtotal  Decimal     @db.Decimal(12, 2)
  total     Decimal     @db.Decimal(12, 2)
  canceled  Boolean     @default(false)
  tracking  String?
  orderDate DateTime    @default(now())
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  user  Account     @relation(fields: [userId], references: [id], onDelete: Restrict)
  items OrderItem[]
}

model OrderItem {
  id          String  @id @default(cuid())
  orderId     String
  productId   String
  warehouseId String
  qty         Int     @default(1)
  unitPrice   Decimal @db.Decimal(12, 2)

  order     Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Restrict)

  @@index([orderId])
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELAYED
  COMPLETED
  CANCELED
  RETURNED
  REFUNDED
}
